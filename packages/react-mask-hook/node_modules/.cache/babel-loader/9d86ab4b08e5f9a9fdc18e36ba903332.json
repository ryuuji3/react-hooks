{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useMemo } from 'react';\nimport useCallbackAfterRender from './useCallbackAfterRender';\nimport getMaskedValue from '../functions/getMaskedValue';\nimport getNextCursorPosition from '../functions/getNextCursorPosition';\nimport useDebugMode from './useDebugMode';\nimport parseMask from '../functions/convertStringMaskToRegexp';\nimport getPlaceholderFromMask from '../functions/getPlaceholderFromMask';\n/**\n * \n * @param value \n * @param onChange \n * @param mask \n * @param displayMask \n */\n\nexport function useMask({\n  value = '',\n  onChange,\n  debug = false,\n  ...props\n}) {\n  _s();\n\n  const mask = useMemo(() => parseMask(props.mask), [props.mask]);\n  const placeholder = useMemo(() => getPlaceholderFromMask(mask, props.placeholder), [mask, props.placeholder]);\n  const maskedValue = getMaskedValue(value, mask, placeholder);\n  const {\n    log\n  } = useDebugMode(debug, {\n    mask,\n    placeholder,\n    value,\n    maskedValue\n  });\n  const lastCursorPosition = getNextCursorPosition(value, mask, log);\n  const scheduleAfterRender = useCallbackAfterRender(); // Using an onChange instead of keyboard events because mobile devices don't fire key events\n\n  function handleChange({\n    target\n  }) {\n    let newValue;\n\n    if (target.value.length > maskedValue.length) {\n      const maskCharacterOrPattern = mask[lastCursorPosition];\n      const insertedCharacter = target.value.charAt(lastCursorPosition);\n\n      if (maskCharacterOrPattern instanceof RegExp && maskCharacterOrPattern.test(insertedCharacter)) {\n        newValue = `${value}${insertedCharacter}`;\n        log(`[useMask] inserted character: ${insertedCharacter}`);\n      } else {\n        newValue = value; // ignore\n\n        log(`[useMask] ignored character: ${insertedCharacter}`);\n      }\n    } else {\n      if (value.length === 0) {\n        const maskCharacterOrPattern = mask[lastCursorPosition];\n        const insertedCharacter = target.value.charAt(0);\n\n        if (maskCharacterOrPattern instanceof RegExp && maskCharacterOrPattern.test(insertedCharacter)) {\n          newValue = insertedCharacter;\n          log(`[useMask] inserted character: ${insertedCharacter}`);\n        } else {\n          newValue = value; // ignore\n\n          log(`[useMask] ignored character: ${insertedCharacter}`);\n        }\n      } else {\n        newValue = value.slice(0, value.length - 1); // Remove a character\n\n        log(`[useMask] removed character`);\n      }\n    }\n\n    onChange(newValue); // onChange is asynchronous so update cursor after it re-renders\n\n    scheduleAfterRender(() => {\n      setCursorPositionForElement(target, getNextCursorPosition(newValue, mask, log));\n    });\n  } // For some reason, tests fail without this...\n  // TODO: Figure out why this is necessary\n\n\n  function onKeyUp({\n    target\n  }) {\n    setCursorPositionForElement(target, lastCursorPosition);\n  }\n\n  function onKeyDown({\n    target\n  }) {\n    // make sure cursor is positioned correctly before input happens\n    // or else the character might not be in the right position\n    setCursorPositionForElement(target, lastCursorPosition);\n  }\n\n  function onFocus({\n    target\n  }) {\n    // Work around in chrome to make sure focus sets cursor position\n    requestAnimationFrame(() => {\n      setCursorPositionForElement(target, getNextCursorPosition(target.value, mask, log));\n    });\n  }\n\n  return {\n    'data-value': value.length ? value : undefined,\n    value: value.length ? maskedValue : '',\n    placeholder,\n    onChange: handleChange,\n    onKeyDown,\n    onKeyUp,\n    onFocus\n  };\n}\n/**\n * Props you need to pass to useMask()\n */\n\n_s(useMask, \"5YzLLXF373BgJc/pXe0y5XLEqWI=\", false, function () {\n  return [useDebugMode, useCallbackAfterRender];\n});\n\n/**\n * \n * @param element \n * @param cursorPosition \n */\nfunction setCursorPositionForElement(element, cursorPosition) {\n  element === null || element === void 0 ? void 0 : element.setSelectionRange(cursorPosition, cursorPosition, 'forward');\n}\n\nexport default useMask;","map":{"version":3,"sources":["/home/codespace/workspace/react-mask-hook/src/hooks/useMask.ts"],"names":["useMemo","useCallbackAfterRender","getMaskedValue","getNextCursorPosition","useDebugMode","parseMask","getPlaceholderFromMask","useMask","value","onChange","debug","props","mask","placeholder","maskedValue","log","lastCursorPosition","scheduleAfterRender","handleChange","target","newValue","length","maskCharacterOrPattern","insertedCharacter","charAt","RegExp","test","slice","setCursorPositionForElement","onKeyUp","onKeyDown","onFocus","requestAnimationFrame","undefined","element","cursorPosition","setSelectionRange"],"mappings":"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","sourcesContent":["import { KeyboardEvent, ChangeEvent, FocusEvent, useMemo, } from 'react'\n\nimport useCallbackAfterRender from './useCallbackAfterRender'\nimport getMaskedValue from '../functions/getMaskedValue'\nimport getNextCursorPosition from '../functions/getNextCursorPosition'\n\nimport useDebugMode from './useDebugMode'\nimport parseMask from '../functions/convertStringMaskToRegexp'\nimport getPlaceholderFromMask from '../functions/getPlaceholderFromMask'\n\n/**\n * \n * @param value \n * @param onChange \n * @param mask \n * @param displayMask \n */\nexport function useMask({\n    value = '',\n    onChange,\n    debug = false,\n    ...props\n}: MaskProps): InputProps {\n    const mask = useMemo(() => parseMask(props.mask), [ props.mask ])\n    const placeholder = useMemo(() => getPlaceholderFromMask(mask, props.placeholder), [ mask, props.placeholder ])\n    const maskedValue = getMaskedValue(value, mask, placeholder)\n    \n    const { log } = useDebugMode(debug, {\n        mask,\n        placeholder,\n        value,\n        maskedValue,\n    })\n    \n    const lastCursorPosition = getNextCursorPosition(value, mask, log)\n    const scheduleAfterRender = useCallbackAfterRender()\n\n    // Using an onChange instead of keyboard events because mobile devices don't fire key events\n    function handleChange({ target }: ChangeEvent<HTMLInputElement>) {\n        let newValue: string\n\n        if (target.value.length > maskedValue.length) {\n            const maskCharacterOrPattern = mask[lastCursorPosition]\n            const insertedCharacter = target.value.charAt(lastCursorPosition)\n\n            if (maskCharacterOrPattern instanceof RegExp && maskCharacterOrPattern.test(insertedCharacter)) {\n                newValue = `${value}${insertedCharacter}`\n                log(`[useMask] inserted character: ${insertedCharacter}`)\n            } else {\n                newValue = value // ignore\n                log(`[useMask] ignored character: ${insertedCharacter}`)\n            }\n        } else {\n            if (value.length === 0) {\n                const maskCharacterOrPattern = mask[lastCursorPosition]\n                const insertedCharacter = target.value.charAt(0)\n\n                if (maskCharacterOrPattern instanceof RegExp && maskCharacterOrPattern.test(insertedCharacter)) {\n                    newValue = insertedCharacter\n                    log(`[useMask] inserted character: ${insertedCharacter}`)\n                } else {\n                    newValue = value // ignore\n                    log(`[useMask] ignored character: ${insertedCharacter}`)\n                }\n            } else {\n                newValue = value.slice(0, value.length - 1) // Remove a character\n                log(`[useMask] removed character`)\n            }\n        }\n\n        onChange(newValue)\n\n        // onChange is asynchronous so update cursor after it re-renders\n        scheduleAfterRender(() => {\n            setCursorPositionForElement(target, getNextCursorPosition(newValue, mask, log))\n        })\n    }\n\n    // For some reason, tests fail without this...\n    // TODO: Figure out why this is necessary\n    function onKeyUp({ target }: KeyboardEvent<HTMLInputElement>) {\n        setCursorPositionForElement(target as HTMLInputElement, lastCursorPosition)\n    }\n\n    function onKeyDown({ target}: KeyboardEvent<HTMLInputElement>) {\n        // make sure cursor is positioned correctly before input happens\n        // or else the character might not be in the right position\n        setCursorPositionForElement(target as HTMLInputElement, lastCursorPosition)\n    }\n\n    function onFocus({ target }: FocusEvent<HTMLInputElement>) {\n        // Work around in chrome to make sure focus sets cursor position\n        requestAnimationFrame(() => {\n            setCursorPositionForElement(target as HTMLInputElement, getNextCursorPosition(target.value, mask, log))\n        })\n    }\n\n    return {\n        'data-value': value.length ? value: undefined,\n        value: value.length ? maskedValue : '',\n        placeholder,\n\n        onChange: handleChange,\n        onKeyDown,\n        onKeyUp,\n        onFocus,\n    }\n}\n\n/**\n * Props you need to pass to useMask()\n */\ninterface MaskProps {\n    value: string\n    onChange: (value: string) => void\n    mask: string | Mask\n    placeholder: string\n    debug?: boolean\n}\n\n/**\n * Props you need to spread onto your input.\n */\ninterface InputProps {\n    'data-value'?: string\n    value: string\n    placeholder: string\n    onChange: (e: ChangeEvent<HTMLInputElement>) => void\n    onKeyDown: (e: KeyboardEvent<HTMLInputElement>) => void\n    onKeyUp: (e: KeyboardEvent<HTMLInputElement>) => void\n    onFocus: (e: FocusEvent<HTMLInputElement>) => void\n}\n\ntype Mask = Array<string | RegExp>\n\n/**\n * \n * @param element \n * @param cursorPosition \n */\nfunction setCursorPositionForElement(element: HTMLInputElement, cursorPosition: number): void {\n    element?.setSelectionRange(cursorPosition, cursorPosition, 'forward')\n}\n\nexport default useMask\nexport type {\n    MaskProps,\n    Mask,\n    InputProps,\n}"]},"metadata":{},"sourceType":"module"}