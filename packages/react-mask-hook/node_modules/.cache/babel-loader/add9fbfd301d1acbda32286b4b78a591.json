{"ast":null,"code":"import { getMaskFromMaskedValue } from './regexHelpers';\nimport fitInputValueIntoMask from './fitInputValueIntoMask';\n\n/**\n * \n * @param value \n * @param mask \n * @param displayMask single character or exact length string\n */\nfunction getMaskedValue(value, mask, displayMask) {\n  return typeof mask === 'string' ? getMaskedValueForStringMask(value, mask, displayMask) : getMaskedValueForRegExpMask(value, mask, displayMask);\n}\n\nfunction getMaskedValueForStringMask(value, mask, displayMask) {\n  let maskCharacters = getMaskFromMaskedValue(mask).split('');\n  const maskedValue = fitInputValueIntoMask(value, mask);\n\n  if (displayMask.length === 1) {\n    return maskedValue.replace(/#/g, displayMask); // single mask character replacement\n  } else if (displayMask.length > 1) {\n    // assuming that the display mask matches the same format as the mask\n    // character differences must be substitutes for mask special characters like '#'\n    maskCharacters = maskedValue.split('');\n    return maskCharacters.reduce((result, currentMaskCharacter, characterIndex) => {\n      if (currentMaskCharacter === '#') {\n        result[characterIndex] = displayMask[characterIndex]; // replace placeholders with matching display mask character\n      }\n\n      return result;\n    }, maskCharacters).join('');\n  }\n\n  return maskedValue; // just use the mask as is if no mask character or display mask was specified\n}\n\nfunction getMaskedValueForRegExpMask(value, mask, displayMask) {\n  const maskedValue = fitInputValueIntoMask(value, mask);\n  return displayMask; // TODO: Implement\n}\n\nexport default getMaskedValue;","map":{"version":3,"sources":["/home/codespace/workspace/react-mask-hook/src/functions/getMaskedValue.ts"],"names":["getMaskFromMaskedValue","fitInputValueIntoMask","getMaskedValue","value","mask","displayMask","getMaskedValueForStringMask","getMaskedValueForRegExpMask","maskCharacters","split","maskedValue","length","replace","reduce","result","currentMaskCharacter","characterIndex","join"],"mappings":"AAAA,SAASA,sBAAT,QAAuC,gBAAvC;AACA,OAAOC,qBAAP,MAAkC,yBAAlC;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAT,CAAwBC,KAAxB,EAAuCC,IAAvC,EAA8DC,WAA9D,EAA2F;AACvF,SAAO,OAAOD,IAAP,KAAgB,QAAhB,GACDE,2BAA2B,CAACH,KAAD,EAAQC,IAAR,EAAcC,WAAd,CAD1B,GAEDE,2BAA2B,CAACJ,KAAD,EAAQC,IAAR,EAAcC,WAAd,CAFjC;AAGH;;AAED,SAASC,2BAAT,CAAqCH,KAArC,EAAoDC,IAApD,EAAkEC,WAAlE,EAA+F;AAC3F,MAAIG,cAAc,GAAGR,sBAAsB,CAACI,IAAD,CAAtB,CAA6BK,KAA7B,CAAmC,EAAnC,CAArB;AACA,QAAMC,WAAW,GAAGT,qBAAqB,CAACE,KAAD,EAAQC,IAAR,CAAzC;;AAEA,MAAIC,WAAW,CAACM,MAAZ,KAAuB,CAA3B,EAA8B;AAC1B,WAAOD,WAAW,CAACE,OAAZ,CAAoB,IAApB,EAA0BP,WAA1B,CAAP,CAD0B,CACoB;AACjD,GAFD,MAEO,IAAIA,WAAW,CAACM,MAAZ,GAAqB,CAAzB,EAA4B;AAC/B;AACA;AACAH,IAAAA,cAAc,GAAGE,WAAW,CAACD,KAAZ,CAAkB,EAAlB,CAAjB;AAEA,WAAOD,cAAc,CAACK,MAAf,CAAsB,CAACC,MAAD,EAASC,oBAAT,EAA+BC,cAA/B,KAAkD;AAC3E,UAAID,oBAAoB,KAAK,GAA7B,EAAkC;AAC9BD,QAAAA,MAAM,CAACE,cAAD,CAAN,GAAyBX,WAAW,CAACW,cAAD,CAApC,CAD8B,CACuB;AACxD;;AAED,aAAOF,MAAP;AACH,KANM,EAMJN,cANI,EAMYS,IANZ,CAMiB,EANjB,CAAP;AAOH;;AAED,SAAOP,WAAP,CApB2F,CAoBxE;AACtB;;AAED,SAASH,2BAAT,CAAqCJ,KAArC,EAAoDC,IAApD,EAAkEC,WAAlE,EAA+F;AAC3F,QAAMK,WAAW,GAAGT,qBAAqB,CAACE,KAAD,EAAQC,IAAR,CAAzC;AAEA,SAAOC,WAAP,CAH2F,CAGxE;AACtB;;AAED,eAAeH,cAAf","sourcesContent":["import { getMaskFromMaskedValue } from './regexHelpers'\nimport fitInputValueIntoMask from './fitInputValueIntoMask'\nimport extractCharacterTokensFromRegex from './extractCharacterTokensFromRegex'\n\n/**\n * \n * @param value \n * @param mask \n * @param displayMask single character or exact length string\n */\nfunction getMaskedValue(value: string, mask: string | RegExp, displayMask: string): string {\n    return typeof mask === 'string'\n        ? getMaskedValueForStringMask(value, mask, displayMask)\n        : getMaskedValueForRegExpMask(value, mask, displayMask) \n}\n\nfunction getMaskedValueForStringMask(value: string, mask: string, displayMask: string): string {\n    let maskCharacters = getMaskFromMaskedValue(mask).split('')\n    const maskedValue = fitInputValueIntoMask(value, mask)\n\n    if (displayMask.length === 1) {\n        return maskedValue.replace(/#/g, displayMask) // single mask character replacement\n    } else if (displayMask.length > 1) {\n        // assuming that the display mask matches the same format as the mask\n        // character differences must be substitutes for mask special characters like '#'\n        maskCharacters = maskedValue.split('')\n\n        return maskCharacters.reduce((result, currentMaskCharacter, characterIndex) => {\n            if (currentMaskCharacter === '#') {\n                result[characterIndex] = displayMask[characterIndex] // replace placeholders with matching display mask character\n            }\n\n            return result\n        }, maskCharacters).join('')\n    }\n\n    return maskedValue // just use the mask as is if no mask character or display mask was specified\n}\n\nfunction getMaskedValueForRegExpMask(value: string, mask: RegExp, displayMask: string): string {\n    const maskedValue = fitInputValueIntoMask(value, mask)\n    \n    return displayMask // TODO: Implement\n}\n\nexport default getMaskedValue"]},"metadata":{},"sourceType":"module"}