{"ast":null,"code":"/**\n * Calculate the new value using existing value, new value, mask and cursor position.\n * \n * TODO: This sucks. How do I make it not suck?\n * \n * @param inputValue \n * @param oldValue \n * @param maskedValue \n * @param mask \n * @param lastCursorPosition \n * @param log \n */\nfunction getNewValue({\n  inputValue,\n  oldValue,\n  maskedValue,\n  mask,\n  lastCursorPosition,\n  log\n}) {\n  let newValue;\n\n  if (inputValue.length > maskedValue.length) {\n    const maskCharacterOrPattern = mask[lastCursorPosition];\n    const insertedCharacter = inputValue.charAt(lastCursorPosition);\n\n    if (maskCharacterOrPattern instanceof RegExp && maskCharacterOrPattern.test(insertedCharacter)) {\n      newValue = `${oldValue}${insertedCharacter}`;\n      log(`[useMask] inserted character: ${insertedCharacter}`);\n    } else {\n      newValue = oldValue; // ignore\n\n      log(`[useMask] ignored character: ${insertedCharacter}`);\n    }\n  } else {\n    if (oldValue.length === 0) {\n      const maskCharacterOrPattern = mask[lastCursorPosition];\n      const insertedCharacter = inputValue.charAt(0);\n\n      if (maskCharacterOrPattern instanceof RegExp && maskCharacterOrPattern.test(insertedCharacter)) {\n        newValue = insertedCharacter;\n        log(`[useMask] inserted character: ${insertedCharacter}`);\n      } else {\n        newValue = oldValue; // ignore\n\n        log(`[useMask] ignored character: ${insertedCharacter}`);\n      }\n    } else {\n      newValue = oldValue.slice(0, oldValue.length - 1); // Remove a character\n\n      log(`[useMask] removed character`);\n    }\n  }\n\n  return newValue;\n}\n\nexport default getNewValue;","map":{"version":3,"sources":["/home/codespace/workspace/react-mask-hook/src/functions/getNewValue.ts"],"names":["getNewValue","inputValue","oldValue","maskedValue","mask","lastCursorPosition","log","newValue","length","maskCharacterOrPattern","insertedCharacter","charAt","RegExp","test","slice"],"mappings":"AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,WAAT,CAAqB;AACjBC,EAAAA,UADiB;AAEjBC,EAAAA,QAFiB;AAGjBC,EAAAA,WAHiB;AAIjBC,EAAAA,IAJiB;AAKjBC,EAAAA,kBALiB;AAMjBC,EAAAA;AANiB,CAArB,EAOsB;AAClB,MAAIC,QAAJ;;AAEA,MAAIN,UAAU,CAACO,MAAX,GAAoBL,WAAW,CAACK,MAApC,EAA4C;AACxC,UAAMC,sBAAsB,GAAGL,IAAI,CAACC,kBAAD,CAAnC;AACA,UAAMK,iBAAiB,GAAGT,UAAU,CAACU,MAAX,CAAkBN,kBAAlB,CAA1B;;AAEA,QAAII,sBAAsB,YAAYG,MAAlC,IAA4CH,sBAAsB,CAACI,IAAvB,CAA4BH,iBAA5B,CAAhD,EAAgG;AAC5FH,MAAAA,QAAQ,GAAI,GAAEL,QAAS,GAAEQ,iBAAkB,EAA3C;AACAJ,MAAAA,GAAG,CAAE,iCAAgCI,iBAAkB,EAApD,CAAH;AACH,KAHD,MAGO;AACHH,MAAAA,QAAQ,GAAGL,QAAX,CADG,CACiB;;AACpBI,MAAAA,GAAG,CAAE,gCAA+BI,iBAAkB,EAAnD,CAAH;AACH;AACJ,GAXD,MAWO;AACH,QAAIR,QAAQ,CAACM,MAAT,KAAoB,CAAxB,EAA2B;AACvB,YAAMC,sBAAsB,GAAGL,IAAI,CAACC,kBAAD,CAAnC;AACA,YAAMK,iBAAiB,GAAGT,UAAU,CAACU,MAAX,CAAkB,CAAlB,CAA1B;;AAEA,UAAIF,sBAAsB,YAAYG,MAAlC,IAA4CH,sBAAsB,CAACI,IAAvB,CAA4BH,iBAA5B,CAAhD,EAAgG;AAC5FH,QAAAA,QAAQ,GAAGG,iBAAX;AACAJ,QAAAA,GAAG,CAAE,iCAAgCI,iBAAkB,EAApD,CAAH;AACH,OAHD,MAGO;AACHH,QAAAA,QAAQ,GAAGL,QAAX,CADG,CACiB;;AACpBI,QAAAA,GAAG,CAAE,gCAA+BI,iBAAkB,EAAnD,CAAH;AACH;AACJ,KAXD,MAWO;AACHH,MAAAA,QAAQ,GAAGL,QAAQ,CAACY,KAAT,CAAe,CAAf,EAAkBZ,QAAQ,CAACM,MAAT,GAAkB,CAApC,CAAX,CADG,CAC+C;;AAClDF,MAAAA,GAAG,CAAE,6BAAF,CAAH;AACH;AACJ;;AAED,SAAOC,QAAP;AACH;;AAWD,eAAeP,WAAf","sourcesContent":["import { Logger } from \"../hooks/useDebugMode\";\nimport { Mask } from \"../hooks/useMask\";\n\n/**\n * Calculate the new value using existing value, new value, mask and cursor position.\n * \n * TODO: This sucks. How do I make it not suck?\n * \n * @param inputValue \n * @param oldValue \n * @param maskedValue \n * @param mask \n * @param lastCursorPosition \n * @param log \n */\nfunction getNewValue({\n    inputValue, \n    oldValue, \n    maskedValue, \n    mask, \n    lastCursorPosition, \n    log,\n}: GetNewValueParams) {\n    let newValue: string\n\n    if (inputValue.length > maskedValue.length) {\n        const maskCharacterOrPattern = mask[lastCursorPosition]\n        const insertedCharacter = inputValue.charAt(lastCursorPosition)\n\n        if (maskCharacterOrPattern instanceof RegExp && maskCharacterOrPattern.test(insertedCharacter)) {\n            newValue = `${oldValue}${insertedCharacter}`\n            log(`[useMask] inserted character: ${insertedCharacter}`)\n        } else {\n            newValue = oldValue // ignore\n            log(`[useMask] ignored character: ${insertedCharacter}`)\n        }\n    } else {\n        if (oldValue.length === 0) {\n            const maskCharacterOrPattern = mask[lastCursorPosition]\n            const insertedCharacter = inputValue.charAt(0)\n\n            if (maskCharacterOrPattern instanceof RegExp && maskCharacterOrPattern.test(insertedCharacter)) {\n                newValue = insertedCharacter\n                log(`[useMask] inserted character: ${insertedCharacter}`)\n            } else {\n                newValue = oldValue // ignore\n                log(`[useMask] ignored character: ${insertedCharacter}`)\n            }\n        } else {\n            newValue = oldValue.slice(0, oldValue.length - 1) // Remove a character\n            log(`[useMask] removed character`)\n        }\n    }\n\n    return newValue\n}\n\ninterface GetNewValueParams {\n    inputValue: string\n    oldValue: string\n    maskedValue: string\n    mask: Mask\n    lastCursorPosition: number\n    log: Logger\n}\n\nexport default getNewValue"]},"metadata":{},"sourceType":"module"}