{"ast":null,"code":"/**\n * Return partial mask with patterns replaced by values.  \n * \n * @param value \n * @param mask\n */\nfunction fitInputValueIntoMask(value, mask) {\n  const valueCharacters = value.split('');\n  let abort = false;\n  return valueCharacters.reduce((outputMask, currentCharacter) => {\n    if (abort) {\n      // If we failed a match then don't attempt to place characters into mask.\n      return outputMask;\n    }\n\n    const firstMaskPattern = findFirstPattern(outputMask);\n\n    if (firstMaskPattern === null || firstMaskPattern === void 0 ? void 0 : firstMaskPattern.test(currentCharacter)) {\n      outputMask[outputMask.indexOf(firstMaskPattern)] = currentCharacter;\n    } else {\n      abort = true;\n    }\n\n    return outputMask;\n  }, [...mask]);\n}\n\nfunction findFirstPattern(mask) {\n  // TypeScript isn't smart enough to realize that this MUST be a RegExp or null, and can never be string.\n  return mask.find(characterOrPattern => characterOrPattern instanceof RegExp);\n}\n\nexport default fitInputValueIntoMask;","map":{"version":3,"sources":["/home/codespace/workspace/react-mask-hook/src/functions/fitInputValueIntoMask.ts"],"names":["fitInputValueIntoMask","value","mask","valueCharacters","split","abort","reduce","outputMask","currentCharacter","firstMaskPattern","findFirstPattern","test","indexOf","find","characterOrPattern","RegExp"],"mappings":"AAGA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,qBAAT,CAA+BC,KAA/B,EAA8CC,IAA9C,EAAgE;AAC5D,QAAMC,eAAe,GAAGF,KAAK,CAACG,KAAN,CAAY,EAAZ,CAAxB;AAEA,MAAIC,KAAK,GAAG,KAAZ;AAEA,SAAOF,eAAe,CAACG,MAAhB,CAAuB,CAACC,UAAD,EAAmBC,gBAAnB,KAAwC;AAClE,QAAIH,KAAJ,EAAW;AAAE;AACT,aAAOE,UAAP;AACH;;AAED,UAAME,gBAA+B,GAAGC,gBAAgB,CAACH,UAAD,CAAxD;;AAEA,QAAIE,gBAAJ,aAAIA,gBAAJ,uBAAIA,gBAAgB,CAAEE,IAAlB,CAAuBH,gBAAvB,CAAJ,EAA8C;AAC1CD,MAAAA,UAAU,CAACA,UAAU,CAACK,OAAX,CAAmBH,gBAAnB,CAAD,CAAV,GAAmDD,gBAAnD;AACH,KAFD,MAEO;AACHH,MAAAA,KAAK,GAAG,IAAR;AACH;;AAED,WAAOE,UAAP;AACH,GAdM,EAcJ,CAAC,GAAGL,IAAJ,CAdI,CAAP;AAeH;;AAED,SAASQ,gBAAT,CAA0BR,IAA1B,EAAqD;AACjD;AACA,SAAOA,IAAI,CAACW,IAAL,CAAUC,kBAAkB,IAAIA,kBAAkB,YAAYC,MAA9D,CAAP;AACH;;AAED,eAAef,qBAAf","sourcesContent":["import { Mask } from '../hooks/useMask'\n\n\n/**\n * Return partial mask with patterns replaced by values.  \n * \n * @param value \n * @param mask\n */\nfunction fitInputValueIntoMask(value: string, mask: Mask): Mask {\n    const valueCharacters = value.split('')\n\n    let abort = false\n\n    return valueCharacters.reduce((outputMask: Mask, currentCharacter) => {\n        if (abort) { // If we failed a match then don't attempt to place characters into mask.\n            return outputMask\n        }\n\n        const firstMaskPattern: RegExp | null = findFirstPattern(outputMask)\n\n        if (firstMaskPattern?.test(currentCharacter)) {\n            outputMask[outputMask.indexOf(firstMaskPattern)] = currentCharacter\n        } else {\n            abort = true\n        }\n\n        return outputMask\n    }, [...mask])\n}\n\nfunction findFirstPattern(mask: Mask): RegExp | null {\n    // TypeScript isn't smart enough to realize that this MUST be a RegExp or null, and can never be string.\n    return mask.find(characterOrPattern => characterOrPattern instanceof RegExp) as RegExp | null\n}\n\nexport default fitInputValueIntoMask"]},"metadata":{},"sourceType":"module"}