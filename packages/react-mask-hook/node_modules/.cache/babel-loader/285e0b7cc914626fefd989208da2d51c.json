{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport useCallbackAfterRender from './useCallbackAfterRender';\nimport getMaskedValue from '../functions/getMaskedValue';\nimport getNextCursorPosition from '../functions/getNextCursorPosition';\nimport { getNumbersFromMaskedValue } from '../functions/regexHelpers';\nimport useDebugMode from './useDebugMode';\n/**\n * \n * @param value \n * @param onChange \n * @param mask \n * @param displayMask \n */\n\nexport default function useMask(value = '', onChange, mask, displayMask, options = defaultOptions) {\n  _s();\n\n  const maskedValue = getMaskedValue(value, mask, displayMask);\n  const placeholder = displayMask;\n  const nextCursorPosition = getNextCursorPosition(value, mask);\n  const scheduleAfterRender = useCallbackAfterRender();\n  useDebugMode(options.debug, {\n    mask,\n    displayMask,\n    value,\n    maskedValue\n  }); // Using an onChange instead of keyboard events because mobile devices don't fire key events\n\n  function handleChange({\n    target\n  }) {\n    console.log(target.value);\n    const numbers = getNumbersFromMaskedValue(target.value);\n    const newValue = target.value.length < placeholder.length // deleted a mask symbol\n    && numbers.length >= value.length // a number was deleted so we don't need to remove another\n    ? numbers.slice(0, numbers.length - 1) // remove a character\n    : numbers;\n    onChange(newValue); // onChange is asynchronous so update cursor after it re-renders\n\n    scheduleAfterRender(() => {\n      setCursorPositionForElement(target, getNextCursorPosition(newValue, mask));\n    });\n  } // For some reason, tests fail without this...\n  // TODO: Figure out why this is necessary\n\n\n  function onKeyUp({\n    target\n  }) {\n    setCursorPositionForElement(target, nextCursorPosition);\n  }\n\n  function onKeyDown({\n    target\n  }) {\n    // make sure cursor is positioned correctly before input happens\n    // or else the character might not be in the right position\n    setCursorPositionForElement(target, nextCursorPosition);\n  }\n\n  function onFocus({\n    target\n  }) {\n    // Work around in chrome to make sure focus sets cursor position\n    requestAnimationFrame(() => {\n      setCursorPositionForElement(target, getNextCursorPosition(target.value, mask));\n    });\n  }\n\n  return {\n    'data-value': value.length ? value : undefined,\n    value: value.length ? maskedValue : placeholder,\n    // render placeholder if they haven't entered anything\n    placeholder,\n    onChange: handleChange,\n    onKeyDown,\n    onKeyUp,\n    onFocus\n  };\n}\n\n_s(useMask, \"6dL5QUk2ZjsatoXNWesp6gmdFnA=\", false, function () {\n  return [useCallbackAfterRender, useDebugMode];\n});\n\nconst defaultOptions = {\n  debug: false\n};\n/**\n * \n * @param element \n * @param cursorPosition \n */\n\nfunction setCursorPositionForElement(element, cursorPosition) {\n  element === null || element === void 0 ? void 0 : element.setSelectionRange(cursorPosition, cursorPosition, 'forward');\n}","map":{"version":3,"sources":["/home/codespace/workspace/react-mask-hook/src/hooks/useMask.ts"],"names":["useCallbackAfterRender","getMaskedValue","getNextCursorPosition","getNumbersFromMaskedValue","useDebugMode","useMask","value","onChange","mask","displayMask","options","defaultOptions","maskedValue","placeholder","nextCursorPosition","scheduleAfterRender","debug","handleChange","target","console","log","numbers","newValue","length","slice","setCursorPositionForElement","onKeyUp","onKeyDown","onFocus","requestAnimationFrame","undefined","element","cursorPosition","setSelectionRange"],"mappings":"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","sourcesContent":["import { useRef, KeyboardEvent, ChangeEvent, FocusEvent, } from 'react'\n\nimport useCallbackAfterRender from './useCallbackAfterRender'\nimport getMaskedValue from '../functions/getMaskedValue'\nimport getNextCursorPosition from '../functions/getNextCursorPosition'\n\nimport { getNumbersFromMaskedValue } from '../functions/regexHelpers'\nimport useDebugMode from './useDebugMode'\n\n/**\n * \n * @param value \n * @param onChange \n * @param mask \n * @param displayMask \n */\nexport default function useMask(\n    value = '',\n    onChange: (value: string) => void,\n    mask: string | RegExp,\n    displayMask: string,\n    options: MaskOptions = defaultOptions,\n) {\n    const maskedValue = getMaskedValue(value, mask, displayMask)\n    const placeholder = displayMask\n    const nextCursorPosition = getNextCursorPosition(value, mask)\n    const scheduleAfterRender = useCallbackAfterRender()\n\n    useDebugMode(options.debug, {\n        mask,\n        displayMask,\n        value,\n        maskedValue,\n    })\n\n    // Using an onChange instead of keyboard events because mobile devices don't fire key events\n    function handleChange({ target }: ChangeEvent<HTMLInputElement>) {\n        console.log(target.value)\n        const numbers = getNumbersFromMaskedValue(target.value)\n        \n        const newValue = (\n            target.value.length < placeholder.length // deleted a mask symbol\n            && numbers.length >= value.length // a number was deleted so we don't need to remove another\n        )\n            ? numbers.slice(0, numbers.length - 1) // remove a character\n            : numbers\n\n        onChange(newValue)\n\n        // onChange is asynchronous so update cursor after it re-renders\n        scheduleAfterRender(() => {\n            setCursorPositionForElement(target, getNextCursorPosition(newValue, mask))\n        })\n    }\n\n    // For some reason, tests fail without this...\n    // TODO: Figure out why this is necessary\n    function onKeyUp({ target }: KeyboardEvent<HTMLInputElement>) {\n        setCursorPositionForElement(target as HTMLInputElement, nextCursorPosition)\n    }\n\n    function onKeyDown({ target}: KeyboardEvent<HTMLInputElement>) {\n        // make sure cursor is positioned correctly before input happens\n        // or else the character might not be in the right position\n        setCursorPositionForElement(target as HTMLInputElement, nextCursorPosition)\n    }\n\n    function onFocus({ target }: FocusEvent<HTMLInputElement>) {\n        // Work around in chrome to make sure focus sets cursor position\n        requestAnimationFrame(() => {\n            setCursorPositionForElement(target as HTMLInputElement, getNextCursorPosition(target.value, mask))\n        })\n    }\n\n    return {\n        'data-value': value.length ? value: undefined,\n        value: value.length ? maskedValue : placeholder, // render placeholder if they haven't entered anything\n        placeholder,\n\n        onChange: handleChange,\n        onKeyDown,\n        onKeyUp,\n        onFocus,\n    }\n}\n\ninterface MaskOptions {\n    debug: boolean\n}\nconst defaultOptions = {\n    debug: false,\n}\n\n/**\n * \n * @param element \n * @param cursorPosition \n */\nfunction setCursorPositionForElement(element: HTMLInputElement, cursorPosition: number): void {\n    element?.setSelectionRange(cursorPosition, cursorPosition, 'forward')\n}"]},"metadata":{},"sourceType":"module"}